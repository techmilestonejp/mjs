/* ---------------------------------------------------------------------------------------------- 
 * 
 * プログラム概要 ： Newさくら麻雀(MJAIクライアント実装版)
 * バージョン     ： 0.1.2.1.232(関数名mentsu,taatsuの名称共通化)
 * プログラム名   ： mjs.exe
 * ファイル名     ： taku.cpp
 * クラス名       ： MJSTaku
 * 処理概要       ： 麻雀卓ゲーム処理クラス
 * Ver0.0.8作成日 ： 2011/11/23 21:26:17
 * Ver0.0.8更新日 ： 2012/05/04 08:58:06
 * Ver0.1.0作成日 ： 2022/06/04 10:13:26
 * Ver0.1.1作成日 ： 2022/06/30 21:19:01
 * Ver0.1.2作成日 ： 2022/08/31 22:19:54
 * 最終更新日     ： 2024/11/07 19:11:07
 * 
 * Copyright (c) 2010-2025 TechMileStoraJP, All rights reserved.
 * 
 * ---------------------------------------------------------------------------------------------- */

#include "taku.h"

/* ---------------------------------------------------------------------------------------------- */
// 初期化処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuInit(){

}

/* ---------------------------------------------------------------------------------------------- */
// 終了処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuPost(){

}

/* ---------------------------------------------------------------------------------------------- */
// 全体処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::CheckTakuStatus(MJSTkinfo *tk, MJSPlayer *ply, bool tmp_push_flg){

	switch(tk->stat){

		/*-----------------------------------------------------------*/
		// 卓開始→場決め
		/*-----------------------------------------------------------*/
		case TAKUSTART:

			/* ------------------------------------ */
			// 初期化処理
			/* ------------------------------------ */

			// 卓処理
			TakuGameInit(tk, ply);

			// 場決め処理
			SetPlySeki(tk,ply);

			// ----------------------------------------
			// 卓状態設定
			// ----------------------------------------
			tk->stat = BAGIME;

		break;

		/*-----------------------------------------------------------*/
		// 場決め→局初期化
		/*-----------------------------------------------------------*/
		case BAGIME:

			// クリックされていれば
			if( tmp_push_flg == true ){

				// ----------------------------------------
				// 卓状態設定
				// ----------------------------------------
				tk->stat = KYOKUSTART;

			}

		break;

		/*-----------------------------------------------------------*/
		// 局開始→配牌
		/*-----------------------------------------------------------*/
		case KYOKUSTART:

			// ----------------------------------------
			// 局情報の初期化
			// ----------------------------------------
			KyokuInit(tk, ply);

			// ----------------------------------------
			// 牌山設定
			// ----------------------------------------

			// 牌山読み取りモード
			if ( tk->yama_setting_mode == 0 ){
				SetYamahai(tk);
			}else{
				ActSeepai(tk);
			}

			// ----------------------------------------
			// 卓情報設定 - ドラ設定
			// ----------------------------------------
			tk->kyoku[tk->kyoku_index].dora[0] = tk->hai_yama[0];

			// ----------------------------------------
			// 卓情報設定 - 配牌
			// ----------------------------------------
			SetHaipai(tk, ply);

			// ----------------------------------------
			// 卓状態設定
			// ----------------------------------------
			tk->stat = HAIPAI;

		break;

		/*-----------------------------------------------------------*/
		// 配牌→ツモ
		/*-----------------------------------------------------------*/
		case HAIPAI:

			// クリックされていれば
			if( tmp_push_flg == true){

				// ----------------------------------------
				// 卓状態設定
				// ----------------------------------------
				tk->stat = PLYACTTSUMO;
			}

		break;

		/*-----------------------------------------------------------*/
		// ツモ→捨牌待ち
		/*-----------------------------------------------------------*/
		case PLYACTTSUMO:

			// ツモ処理
			TakuActTsumo(tk, ply , tk->hai_yama[tk->hai_point], tk->yamahai_index[tk->hai_point], false);

			// ポインタ加算
			tk->hai_point++;

			// ----------------------------------------
			// 卓状態設定
			// ----------------------------------------
			tk->stat = PLYACTSUTEWAIT;

		break;

		/*-----------------------------------------------------------*/
		// リンシャンツモ→捨牌待ち
		/*-----------------------------------------------------------*/
		case PLYRINSHAN:

			// リンシャン枚数確認
			if(tk->rinshan_point == 14){

				// ５枚目槓で終了
				tk->stat = RYUKYOKU;

				// 流局情報設定
				// Set4Kaikan();

			}else{

				// ツモ処理
				TakuActTsumo(tk, ply , tk->hai_yama[tk->rinshan_point], tk->yamahai_index[tk->rinshan_point], true);

				// ポインタ加算
				tk->rinshan_point++;

				// ----------------------------------------
				// 卓状態設定
				// ----------------------------------------
				tk->stat = PLYACTSUTEWAIT;

			}

		break;

		/*-----------------------------------------------------------*/
		// 捨牌設定
		/*-----------------------------------------------------------*/
		case PLYACTSUTEWAIT:

			// クリックされていれば
			if( tmp_push_flg == true){

				// ----------------------------------------
				// 捨牌処理 →「卓状態設定」はTakuActPostTsumo関数内で決定
				// ----------------------------------------
				TakuActPostTsumo(tk, ply);

			}

		break;

		/*-----------------------------------------------------------*/
		// 鳴き後アクションの設定
		/*-----------------------------------------------------------*/
		case PLYACTNAKISUTEWAIT:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 鳴き捨牌処理
				TakuActPostNaki(tk, ply);

				// ----------------------------------------
				// 卓状態設定（→鳴き捨牌処理）
				// ----------------------------------------
				tk->stat = PLYACTNAKISUTE;

			}

		break;

		/*-----------------------------------------------------------*/
		// 捨牌状態変更(自摸捨て)
		/*-----------------------------------------------------------*/
		case PLYACTSUTE:

			// 鳴き確認
			ChkPlayNaki(tk, ply);

			// 状態設定
			tk->stat = PLYACTNAKIWAIT;

		break;

		/*-----------------------------------------------------------*/
		// 捨牌状態変更(鳴き捨牌)
		/*-----------------------------------------------------------*/
		case PLYACTNAKISUTE:

			// 鳴き確認
			ChkPlayNaki(tk, ply);

			// 状態設定
			tk->stat = PLYACTNAKIWAIT;

		break;

		/*-----------------------------------------------------------*/
		// リーチ状態変更
		/*-----------------------------------------------------------*/
		case PLYACTRIICH:

			// 手牌確認
			ply[tk->ply_turn].PlyActTsumo(tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1], 
			                              tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count-1]);

			// 状態設定
			tk->stat = PLYACTSUTEWAIT;

		break;

		/*-----------------------------------------------------------*/
		// 鳴きの有無を確認→各鳴き処理 or 次のツモ処理
		/*-----------------------------------------------------------*/
		case PLYACTNAKIWAIT:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 鳴き情報の設定→「卓ステータス」の設定
				SetPlayNaki(tk, ply);

			}
		
		break;

		/*-----------------------------------------------------------*/
		// ポン処理
		/*-----------------------------------------------------------*/
		case PLYACTPON:

			// 状態変更
			tk->stat = PLYACTNAKISUTEWAIT;

		break;

		/*-----------------------------------------------------------*/
		// チー処理
		/*-----------------------------------------------------------*/
		case PLYACTCHI:

			//状態変更
			tk->stat = PLYACTNAKISUTEWAIT;

		break;

		/*-----------------------------------------------------------*/
		// 明槓処理
		/*-----------------------------------------------------------*/
		case PLYACTMINKAN:

			// クリックされていれば
			if( tmp_push_flg == true){

				// リンシャン設定
				tk->stat = PLYRINSHAN;
			}

		break;

		/*-----------------------------------------------------------*/
		// 暗槓処理
		/*-----------------------------------------------------------*/
		case PLYACTANKAN:

			// クリックされていれば
			if( tmp_push_flg == true){

				// リンシャン設定
				tk->stat = PLYRINSHAN;

			}

		break;

		/*-----------------------------------------------------------*/
		// 加槓処理
		/*-----------------------------------------------------------*/
		case PLYACTKAKAN:

			// クリックされていれば
			if( tmp_push_flg == true){

				// リンシャン設定
				tk->stat = PLYRINSHAN;

			}

		break;

		/*-----------------------------------------------------------*/
		// ツモ待ち処理(捨牌後の処理)→ツモ処理
		/*-----------------------------------------------------------*/
		case PLYACTTSUMOWAIT:

			// 牌山ポインタが越えたら終了
			if ( tk->hai_point + (tk->rinshan_point - RINSHAN_POINT_START) >= PAI_COUNT_MAX ){
//			if ( tk->hai_point + (tk->rinshan_point - RINSHAN_POINT_START) >= 68 ){

				// 荒牌処理
				SetHowanpai(tk, ply);

				// ----------------------------------------
				// 卓状態設定（→流局）
				// ----------------------------------------
				tk->stat   = RYUKYOKU;

			}else{

				// 次のプレーヤーに順番変更
				tk->ply_turn = (tk->ply_turn+1) % 4;

				// ----------------------------------------
				// 状態設定（→ツモ処理）
				// ----------------------------------------
				tk->stat = PLYACTTSUMO;

			}

		break;

		/*-----------------------------------------------------------*/
		// ツモアガリ処理
		/*-----------------------------------------------------------*/
		case PLYTSUMOAGARI:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 状態設定
				tk->stat = KYOKURESULT;

			}

		break;

		/*-----------------------------------------------------------*/
		// ロン処理
		/*-----------------------------------------------------------*/
		case PLYACTRON:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 状態設定
				tk->stat = KYOKURESULT;

			}

		break;

		/*-----------------------------------------------------------*/
		// 流局
		/*-----------------------------------------------------------*/
		case RYUKYOKU:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 状態設定
				tk->stat = KYOKURESULT;

			}

		break;

		/*-----------------------------------------------------------*/
		// 局結果表示
		/*-----------------------------------------------------------*/
		case KYOKURESULT:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 状態設定
				tk->stat = KYOKUEND;

			}

		break;

		/*-----------------------------------------------------------*/
		// 局終了
		/*-----------------------------------------------------------*/
		case KYOKUEND:

			// -----------------------------------------------------------
			// 次局処理
			// -----------------------------------------------------------
			KyokuNextInit(tk, ply);

			// -----------------------------------------------------------
			// 卓終了時の結果設定
			// -----------------------------------------------------------
			SetTakuReSult(tk, ply);

		break;

		/*-----------------------------------------------------------*/
		// 卓結果表示
		/*-----------------------------------------------------------*/
		case TAKURESULT:

			// クリックされていれば
			if( tmp_push_flg == true){

				// 状態設定
				tk->stat = TAKUEND;

			}

		break;

		/*-----------------------------------------------------------*/
		// 卓終了
		/*-----------------------------------------------------------*/
		case TAKUEND:

		break;

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 卓開始処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuGameInit(MJSTkinfo *tk, MJSPlayer *ply){

	// ----------------------------------------
	// 卓情報の初期化
	// ----------------------------------------

	// 人かCOMか(0：全員COM、1：人プレーヤーあり)
	// tk->ply_hum_mode = 0;
	// tk->ply_hum_mode = 1;

	// 赤牌枚数設定
	tk->aka_max[0] = 4;  // 萬子の赤牌枚数
	tk->aka_max[1] = 4;  // 筒子の赤牌枚数
	tk->aka_max[2] = 4;  // 索子の赤牌枚数

	// プレーヤ初期化
	for( int tmp_pnum = 0; tmp_pnum < 4 ; tmp_pnum++ ) {
		// プレーヤー初期化
		ply[tmp_pnum].PlyActTakuStart(tmp_pnum);
	}

	// ----------------------------------------
	// 卓情報の設定
	// ----------------------------------------

	// 卓情報
	wsprintf(tk->tkgname,   "%s", "さくら麻雀");     // ゲーム名
	wsprintf(tk->tkno  ,    "%s", "8888");           // 卓番号
	// wsprintf(tk->startdate, "%s", "2024/02/04");     // 卓開始日
	// wsprintf(tk->starttime, "%s", "11:30:20");       // 卓開始時刻
	wsprintf(tk->enddate,   "%s", "2024/02/04");     // 卓終了日
	wsprintf(tk->endtime,   "%s", "11:42:18");       // 卓終了時刻

	// ゲーム名設定
	if(tk->tkgame_type == TKGAME_TONPU){
		wsprintf(tk->tkname, "%s", "東風戦");
	}else if(tk->tkgame_type == TKGAME_HANCHAN){
		wsprintf(tk->tkname, "%s", "半荘戦");
	}else if(tk->tkgame_type == TKGAME_1KYOKU){
		wsprintf(tk->tkname, "%s", "一局戦");
	}else if(tk->tkgame_type == TKGAME_MAXID_TEST){
		wsprintf(tk->tkname, "%s", "検証用");
	}else {
		wsprintf(tk->tkname, "%s", "不明");
	}

	// ゲーム名設定
	if(tk->ply_hum_mode == 0){
		wsprintf(tk->tkname, "%s%s", tk->tkname, "COM");
	}else if(tk->ply_hum_mode == 1){
		wsprintf(tk->tkname, "%s%s", tk->tkname, "HUM");
	}else {
		wsprintf(tk->tkname, "%s%s", tk->tkname, "NON");
	}

	// ゲーム名設定
	if(tk->yama_setting_mode == 0){
		wsprintf(tk->tkname, "%s%s", tk->tkname, "牌テーブル読込");         // 卓名
	}else if(tk->yama_setting_mode == 1){
		wsprintf(tk->tkname, "%s%s", tk->tkname, "ランダムモード：変数");   // 卓名
	}else if(tk->yama_setting_mode == 2){
		wsprintf(tk->tkname, "%s%s", tk->tkname, "ランダムモード：固定");   // 卓名
	}else{
		wsprintf(tk->tkname, "%s%s", tk->tkname, "不明");                   // 卓名
	}

	wsprintf(tk->plyname[0], "%s", "ひまわり赤");
	wsprintf(tk->plyname[1], "%s", "ひまわり青");
	wsprintf(tk->plyname[2], "%s", "ひまわり黄");

	// プレーヤ名の設定(HUMプレーヤー)
	if(tk->ply_hum_mode == 1){
		wsprintf(tk->plyname[HUM_PLY_SEKI_NUM], "%s", "あなた");
	}else{
		wsprintf(tk->plyname[HUM_PLY_SEKI_NUM], "%s", "ひまわり緑");
	}

	// シード値設定
	if( tk->yama_setting_mode == 0 ){
		tk->core_seed_num = 0;
	}else if( tk->yama_setting_mode == 1 ){
		SetTimeSeedNum(tk);
	}else{
		tk->core_seed_num = SEED_NUM;
	}

}

/* ---------------------------------------------------------------------------------------------- */
// 現在時刻の取得
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetNowTime(MJSTkinfo *tk){

	// システム関数定義 
    time_t jikan = time(NULL);
    struct tm imanojikan;
	errno_t error;

	// 時間変数の定義
	int year, mon, day;
	int hour, min, sec;

	// 現在の日時を取得 
	error = localtime_s(&imanojikan, &jikan);

	// 時間変数の代入
	year = imanojikan.tm_year + 1900;
	mon  = imanojikan.tm_mon  + 1;
	day  = imanojikan.tm_mday ;

	hour = imanojikan.tm_hour;
	min  = imanojikan.tm_min;
	sec  = imanojikan.tm_sec;

	wsprintf(tk->startdate, "%04d/%02d/%02d", year, mon, day);     // 卓開始日
	wsprintf(tk->starttime, "%02d:%02d:%02d", hour, min, sec);     // 卓開始時刻

}

/* ---------------------------------------------------------------------------------------------- */
// プレーヤーの席決め
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetPlySeki(MJSTkinfo *tk, MJSPlayer *ply){

	// ----------------------------------------
	// 家の設定(プレーヤの席決め)
	// ----------------------------------------

	// 家情報設定
	tk->kyoku[tk->kyoku_index].ie[0] = 1;   // プレーヤー01は西家
	tk->kyoku[tk->kyoku_index].ie[1] = 2;   // プレーヤー02は北家
	tk->kyoku[tk->kyoku_index].ie[2] = 3;   // プレーヤー03は東家
	tk->kyoku[tk->kyoku_index].ie[3] = 0;   // プレーヤー04は南家

	// 起家設定
	tk->kyoku[tk->kyoku_index].kyoku_oya = 3;

}

/* ---------------------------------------------------------------------------------------------- */
// 局開始処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::KyokuInit(MJSTkinfo *tk, MJSPlayer *ply){

	// ----------------------------------------
	// 局情報初期化
	// ----------------------------------------
	tk->KyokuInit();

	// 現在時刻の取得
	SetNowTime(tk);

	// ----------------------------------------
	// 手番設定
	// ----------------------------------------
	tk->ply_turn = tk->kyoku[tk->kyoku_index].kyoku_oya;

	// ----------------------------------------
	// プレーヤ初期化
	// ----------------------------------------

	// プレーヤ初期化
	for( int tmp_pnum = 0; tmp_pnum < 4 ; tmp_pnum++ ) {

		// プレーヤーアクション - 局開始
		ply[tmp_pnum].PlyActKyokuStart(0,0,0,0, tk->kyoku[tk->kyoku_index].ie[tmp_pnum], tk->kyoku[tk->kyoku_index].dora[0]);

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 洗牌処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::ActSeepai(MJSTkinfo *tk){

	// 初期設定
	int hai1;
	int hai2;
	int tnum;

	// シード値設定
	if( tk->yama_setting_mode == 0 ){
		tk->kyoku[tk->kyoku_index].seed_num = 0;
	}else{
		tk->kyoku[tk->kyoku_index].seed_num = tk->core_seed_num + tk->kyoku_index;
	}

	// 乱数発生
	srand( tk->kyoku[tk->kyoku_index].seed_num );

	// 牌定義
	for (int i = 0; i < 4; i++){

		// 通常牌
		for (int j = 0; j < 34; j++){

			// 通常牌
			if ( j <= 8 ){
				tk->hai_yama[i*34+j] = j+1;
			}else if( 9 <= j && j <= 17 ){
				tk->hai_yama[i*34+j] = j+2;
			}else if( 18 <= j && j <= 26 ){
				tk->hai_yama[i*34+j] = j+3;
			}else if( 27 <= j && j <= 33 ){
				tk->hai_yama[i*34+j] = j+4;
			}

			// 牌種別
			tk->yamahai_index[i*34+j] = i;

		}
	}

	// 牌のシャッフル 
	for (int i = 0; i < 20000; i++){

		// 乱数発生
		hai1 = rand() % PAI_COUNT_MAX;
		hai2 = rand() % PAI_COUNT_MAX;

		// 通常牌
		tnum = tk->hai_yama[hai1];
		tk->hai_yama[hai1] = tk->hai_yama[hai2];
		tk->hai_yama[hai2] = tnum;

		// 牌種別
		tnum = tk->yamahai_index[hai1];
		tk->yamahai_index[hai1] = tk->yamahai_index[hai2];
		tk->yamahai_index[hai2] = tnum;

	}
}

/* ---------------------------------------------------------------------------------------------- */
// 時間シード番号設定
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetTimeSeedNum(MJSTkinfo *tk){

	// システム関数定義 
    time_t jikan = time(NULL);
    struct tm imanojikan;
	errno_t error;

	// 時間変数の定義
	int year, mon, day;
	int hour, min, sec;

	// 現在の日時を取得 
	error = localtime_s(&imanojikan, &jikan);

	// 時間変数の代入
	year = imanojikan.tm_year + 1900;
	mon  = imanojikan.tm_mon  + 1;
	day  = imanojikan.tm_mday ;

	hour = imanojikan.tm_hour;
	min  = imanojikan.tm_min;
	sec  = imanojikan.tm_sec;

	// tk->kyoku[tk->kyoku_index].seed_num = mon*31*60*24*60 + day*60*24*60 + hour*60*60 + min*60 + sec;
	tk->core_seed_num =  mon*31*60*24*60 + day*60*24*60 + hour*60*60 + min*60 + sec;

}

/* ---------------------------------------------------------------------------------------------- */
// 牌山設定
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetYamahai(MJSTkinfo *tk){

	// 乱数は仮番号
	tk->kyoku[tk->kyoku_index].seed_num = 0;

	// 牌山テーブル
	int tmp_hai_yama[] = {  4,25,35, 4, 5,                                      // 表ドラ
                            1, 2, 8, 4, 5,                                      // 裏ドラ
                            32,33,34,35,                                        // リンシャン

//                          21,21,21,22,23,24,25,26,27,28,29,29,29,               // 配牌：プレーヤー(チューレン)
//                          31,31,31,32,32,32,33,33,34,34,34,37,37,               // 配牌：プレーヤー1(ショースーシー)
//                           1, 4, 7,11,14,19,19,35,35,36,36,37,37,               // 配牌：プレーヤーX
//                           1, 5, 5,15,15,25,25,35,35,36,36,37,37,               // 配牌：プレーヤーX(赤3つカカン)
//                           5, 5, 5, 5,15,15,15,15,25,25,25,25,18,               // 配牌：プレーヤー1(赤3つアンカン)
//                           5,15,15,15,15,25,25,25,25,35,35,35,35,               // 配牌：プレーヤー3(赤3つアンカン)
//                           5, 5, 5, 5,15,15,15,25,25,25,25,31,32,               // 配牌：プレーヤー(赤3つアンカン)
//                          11,11,11,18,18,35,35,36,36,36,37,37,37,               // 配牌：プレーヤー3(ショーサンゲン)
//                          12,12,13,13,14,14,15,15,16,16,17,17,18,               // 配牌：プレーヤー3(ダイシャリン)
//                          31,31,31,31,32,32,32,32,33,33,33,33,34,               // 配牌：プレーヤー3(ショースーシー・アンカン)
//                          11,12,13,14,15,15,15,16,17,18,19,34,34,               // 配牌：プレーヤー3(イッツー)
//                           5, 6,11,12,13,14,15,16,17,18,19,31,31,               // 配牌：プレーヤー3(イッツー)
//                          11,11,11,19,19,35,35,36,36,36,37,37,31,               // 配牌：プレーヤー3(ショーサンゲン)/
//                           2, 3,12,13,17,19,21,22,23,31,31,33,34,               // 配牌：プレーヤー3(三色チー)
//                           5, 5, 5, 5,15,15,15,15,25,25,25,25,34,               // 配牌：プレーヤー3(サンショクドーコー)
//                           5, 5, 5,15,15,15,25,25,25,31,32,33,34,               // 配牌：プレーヤー3(サンショクドーコー)
//                           7, 8, 9,17,18,19,27,28,29,31,31,31,33,               // 配牌：プレーヤー3(サンショクドウジュン)
//                           5, 5, 5,15,15,15,25,25,25,31,32,33,34,               // 配牌：プレーヤー3(サンショクドーコー)


/*
                         31,31,31,32,32,32,33,33,33,34,34,34,35,                  // 配牌：「全鳴き状態」の確認④
                         11,11,25,12,12,12,16,17,19,19,19,32,32,                  // 配牌：「全鳴き状態」の確認①
                         11,11,24,12,12,12,16,17,19,19,19,32,32,                  // 配牌：「全鳴き状態」の確認②
                         11,11,24,12,12,12,16,17,19,19,19,32,32,                  // 配牌：「全鳴き状態」の確認③
                          5, 6,24,25,25,25,26,27,28,31,31,31,32,                  // 配牌：「全鳴き状態」の確認④


                          1, 1, 5, 5, 5, 9, 9,35,35,35,31,32,33,                  // 配牌：鳴き確認①
                         11,11,15,15,15,19,19,36,36,36,31,32,33,                  // 配牌：鳴き確認②
                         21,21,25,25,25,29,29,37,37,37,31,32,33,                  // 配牌：鳴き確認③
                         31,31,31,32,32,32,33, 1, 9,11,19,21,29,                  // 配牌：鳴き確認④
*/

                          5,15,25,31,31,31,35,35,35,36,36,36,37,                // 配牌：プレーヤー(チューレン)
                          3, 4,13,14,23,24,35,35,35,36,36,36,37,                // 配牌：プレーヤー(チューレン)
                         19,21,21,22,23,24,25,26,27,28,29,29,29,                // 配牌：プレーヤー(チューレン)
                         24,24,25,26,26,17,17,18,18,19,19, 5, 5,                // 配牌：プレーヤー(チューレン)

//                          1,11,21, 9, 1,29,31,32,33,34,35,36,37,                  // 配牌：プレーヤー(コクシムソウ)
//                          1,11,21, 9,19,29,31,32,33,34,35,36,37,                  // 配牌：プレーヤー(コクシムソウ13メン)
//                         11,11,11,12,13,14,15,16,17,18,19,19,19,                  // 配牌：プレーヤー(ピンズ：チューレン)
//                         31,31,32,32,33,33,34,35,35,36,36,37,37,                  // 配牌：プレーヤー(チートイツ・ツーイーソー)
//                         11,11,31,31,32,32,33,33,34,34,35,35,12,                  // 配牌：プレーヤー(チートイツ・ホンロート)
//                         11,12,13,14,15,32,32,33,33,34,34,35,35,                  // 配牌：プレーヤー(3面チー確認)


//                           5, 15,25,18, 18,18,  5, 15,25,35,35, 35,18,18,18,     // 自摸(70枚)：01巡目から04巡目
//                          33,33,34,33, 34,32,33,34, 35,18,18,18, 18,18,18,18,    // 自摸(70枚)：01巡目から04巡目
//                           1,11,18,34, 18,18,18,18, 18,18,18,18, 18,18,18,18,    // 自摸(70枚)：01巡目から04巡目
//                          34, 5,15,13, 19,19,19,19, 18,18,18,18, 18,18,18,18,    // 自摸(70枚)：01巡目から04巡目

                          37,37,37,37, 15,16,17,18, 19,11,12,13, 14,15,16,17,   // 自摸(70枚)：01巡目から04巡目
                          19,19,19,19, 19,18,18,18, 18,18,18,18, 18,18,18,18,   // 自摸：05巡目から08巡目
                          18,18,18,18, 18,18,18,18, 18,18,18,18, 18,18,18,18,   // 自摸：09巡目から12巡目
                          18,18,18,18, 18,18,18,18, 18,18,18,18, 18,18,18,18,   // 自摸：13巡目から16巡目
                          18,18,18,18, 18,18                                    // 自摸：17巡目から18巡目

                       };

	// 牌INDEXテーブル
	int tmp_yamahai_index[] = {  0, 0, 0, 0, 0,                                 // 表ドラ
                                 0, 0, 0, 0, 0,                                 // 裏ドラ
                                 0, 0, 0, 0,                                    // リンシャン

                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 配牌：プレーヤー1
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 配牌：プレーヤー2
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 配牌：プレーヤー3
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 配牌：プレーヤー4

                           0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,   // 自摸(70枚)：01巡目から04巡目
                           0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,   // 自摸：05巡目から08巡目
                           0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,   // 自摸：09巡目から12巡目
                           0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,   // 自摸：13巡目から16巡目
                           0, 0, 0, 0,  0, 0                                    // 自摸：17巡目から18巡目
                       };

	// 牌定義
	for (int i = 0; i < PAI_COUNT_MAX; i++){
		tk->hai_yama[i]       = tmp_hai_yama[i];
		tk->yamahai_index[i] = tmp_yamahai_index[i];
	}

}

/* ---------------------------------------------------------------------------------------------- */
// 配牌処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetHaipai(MJSTkinfo *tk, MJSPlayer *ply){

	// ----------------------------------------
	// 配牌処理(tkクラス内で処理するように変更する)
	// ----------------------------------------

	for(int tmp_num=0; tmp_num< PLAYER_MAX; tmp_num++){
		for(int tmp_i=0; tmp_i< TEHAI_MAX; tmp_i++){
			// 手牌追加
			tk->kyoku[tk->kyoku_index].tehai[tmp_num][tk->hai_yama[14+TEHAI_MAX*tmp_num+tmp_i]]++;
			// 赤牌追加
			for(int tmp_j = 0; tmp_j < AKA_TYPE_MAX_COUNT; tmp_j++){
				if(tk->hai_yama[14+TEHAI_MAX*tmp_num+tmp_i] == 10*tmp_j+5 && tk->yamahai_index[14+TEHAI_MAX*tmp_num+tmp_i] < tk->aka_max[tmp_j]){
					tk->kyoku[tk->kyoku_index].aka_count[tmp_num][tmp_j]++;
				}
			}
		}
	}

	// ----------------------------------------
	// プレーヤーへの配牌設定
	// ----------------------------------------

	// 配牌時のプレーヤー情報の設定
	for( int tmp_pnum = 0; tmp_pnum < PLAYER_MAX; tmp_pnum++ ) {

		// 配牌設定
		for(int tmp_i=0; tmp_i< TEHAI_MAX; tmp_i++){;
			// 牌設定
			ply[tmp_pnum].PlyActHaipai(tk->hai_yama[14+TEHAI_MAX*tmp_pnum+tmp_i],false);
		}

		// 赤牌設定
		for(int tmp_aka_grp = 0; tmp_aka_grp < AKA_TYPE_MAX_COUNT; tmp_aka_grp++){;
			ply[tmp_pnum].aka_count[tmp_aka_grp] = tk->kyoku[tk->kyoku_index].aka_count[tmp_pnum][tmp_aka_grp];
		}

		// 配牌後の確認処理
		ply[tmp_pnum].PlyActPostHaipai();

	}

	// ----------------------------------------
	// アクション情報設定 - 配牌時
	// ----------------------------------------

	tk->kyoku[tk->kyoku_index].act_stat[0]  = HAIPAI;
	tk->kyoku[tk->kyoku_index].act_ply[0]   = 4;
	tk->kyoku[tk->kyoku_index].react_ply[0] = 4;
	tk->kyoku[tk->kyoku_index].act_hai[0]   = 0;

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸処理orリンシャン処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActTsumo(MJSTkinfo *tk, MJSPlayer *ply, int tmp_tsumo_hai, int tmp_tsumo_hai_index, bool tmp_rinshan_mode){

	// ----------------------------------------
	// 自摸アクション処理 - 自摸処理orリンシャン処理
	// ----------------------------------------

	// 初期化
	int tmp_tsumo_aka = false;

	// 赤牌設定
	if( ( tmp_tsumo_hai ==  5 && tmp_tsumo_hai_index < tk->aka_max[0]) || 
	    ( tmp_tsumo_hai == 15 && tmp_tsumo_hai_index < tk->aka_max[1]) || 
	    ( tmp_tsumo_hai == 25 && tmp_tsumo_hai_index < tk->aka_max[2]) ){
			tmp_tsumo_aka = true;
		}else{
			tmp_tsumo_aka = false;
	}

	// アクション定義
	if(tmp_rinshan_mode == true){

		// アクション設定 - リンシャン処理
		tk->SetActInfo(tk->kyoku_index,
			PLYRINSHAN,
			tk->ply_turn,
			4,
			tmp_tsumo_hai,
			tmp_tsumo_aka
		);

	}else{

		// アクション設定 - 自摸処理
		tk->SetActInfo(tk->kyoku_index,
			PLYACTTSUMO,
			tk->ply_turn,
			4,
			tmp_tsumo_hai,
			tmp_tsumo_aka
		);

	}

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// ----------------------------------------
	// plyクラスに自摸情報送信
	// ----------------------------------------

	// 手牌確認
	ply[tk->ply_turn].PlyActTsumo(tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count], 
	                              tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]);

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPostTsumo(MJSTkinfo *tk, MJSPlayer *ply){

	// HUM・COM処理確認
	if( tk->ply_hum_mode == 1 && tk->ply_turn == 3){
		// 自摸後アクション処理・HUMの場合
		TakuActPostTsumo_HumPly(tk);
	}else{
		// 自摸後アクション処理・COMの場合
		TakuActPostTsumo_ComPly(tk, ply);
	}

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・HUMの場合
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPostTsumo_HumPly(MJSTkinfo *tk){

	// --------------------------------------------
	// プレーヤーアクションの確認(自摸和了)
	// --------------------------------------------
	if(tk->ply_act == ACTTSUMOAGARI){

		// 自摸和了処理
		TakuActTsumoAgari(tk);

	// --------------------------------------------
	// プレーヤーアクションの確認(リーチ)
	// --------------------------------------------
	}else if(tk->ply_act == ACTRIICH){

		// リーチ処理
		TakuActRiichi(tk);

	// --------------------------------------------
	// プレーヤーアクションの確認(暗槓)
	// --------------------------------------------
	}else if(tk->ply_act == ACTANKAN ){

		// 暗槓処理
		TakuActAnkan(tk, tk->ply_naki_idx[HUM_PLY_SEKI_NUM]);

	// --------------------------------------------
	// プレーヤーアクションの確認(加槓)
	// --------------------------------------------
	}else if(tk->ply_act == ACTKAKAN ){

		// 加槓処理
		TakuActKakan(tk, tk->ply_naki_idx[HUM_PLY_SEKI_NUM], tk->ply_naki_aka_count[HUM_PLY_SEKI_NUM]);

	// --------------------------------------------
	// アクションが「自摸切り」であれば
	// --------------------------------------------
	}else if((tk->ply_act == ACTTSUMOGIRI ) ||                                                                                 // 自摸切り
	         (tk->ply_act == ACTSUTE        && tk->ply_tbl_hum_sutehai_statnum == tk->ply_act_tehaicount[HUM_PLY_SEKI_NUM])    // 捨牌アクションで捨牌が自摸切牌
	        ){

		// 自摸切り処理
		TakuActTsumoGiri(tk);

	// --------------------------------------------
	// アクションが「捨牌」であれば
	// --------------------------------------------
	}else if(tk->ply_act == ACTSUTE){

		// 捨牌処理
		TakuActSutehai( tk,
		                tk->ply_act_tehaitbl[HUM_PLY_SEKI_NUM][tk->ply_tbl_hum_sutehai_statnum],
		                tk->ply_act_tehai_tbl_aka[HUM_PLY_SEKI_NUM][tk->ply_tbl_hum_sutehai_statnum] );

	// --------------------------------------------
	// 例外処理(デバグ用)
	// --------------------------------------------
	}else{

		// 自摸切り処理
		// TakuActTsumoGiri(tk);

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・COMの場合
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPostTsumo_ComPly(MJSTkinfo *tk, MJSPlayer *ply){

	// 自摸後アクションの設定
	tk->ply_act = ply[tk->ply_turn].ply_act;

	// --------------------------------------------
	// プレーヤーアクションの確認(自摸和了)
	// --------------------------------------------
	if(tk->ply_act == ACTTSUMOAGARI){

		// 自摸和了処理
		TakuActTsumoAgari(tk);

	// --------------------------------------------
	// プレーヤーアクションの確認(リーチ宣言処理)
	// --------------------------------------------
	}else if(tk->ply_act == ACTRIICH){

		// 自摸和了処理
		TakuActRiichi(tk);

	// --------------------------------------------
	// プレーヤーアクションの確認(暗槓)
	// --------------------------------------------
	}else if(tk->ply_act == ACTANKAN ){

		// プレーヤーアクション - 暗槓
		ply[tk->ply_turn].PlyActAnkan(ply[tk->ply_turn].ply_naki_idx);

		// 暗槓処理
		TakuActAnkan(tk, ply[tk->ply_turn].ply_naki_idx);

	// --------------------------------------------
	// プレーヤーアクションの確認(加槓)
	// --------------------------------------------
	}else if(tk->ply_act == ACTKAKAN ){

		// プレーヤーアクション - 加槓
		ply[tk->ply_turn].PlyActKakan(ply[tk->ply_turn].ply_naki_idx, ply[tk->ply_turn].ply_naki_aka_count);

		// 加槓処理
		TakuActKakan(tk, ply[tk->ply_turn].ply_naki_idx, ply[tk->ply_turn].ply_naki_aka_count);

	// --------------------------------------------
	// プレーヤーアクションの確認(自摸切り)
	// --------------------------------------------
	}else if((tk->ply_act == ACTTSUMOGIRI)        // 自摸切り
	      ){

		// 自摸切り処理
		TakuActTsumoGiri(tk);

		// プレーヤーの捨牌処理
		ply[tk->ply_turn].PlyActTsumoSute();

	// --------------------------------------------
	// プレーヤーアクションの確認(捨牌)
	// --------------------------------------------
	}else if(tk->ply_act == ACTSUTE){

		// 捨牌処理
		TakuActSutehai( tk, 
		                ply[tk->ply_turn].ply_sute_hai, 
		                ply[tk->ply_turn].ply_sute_aka);

		// プレーヤーの捨牌処理
		ply[tk->ply_turn].PlyActTsumoSute();

	// --------------------------------------------
	// 例外処理(デバグ用)
	// --------------------------------------------
	}else{

		// 自摸切り処理
		// TakuActTsumoGiri(tk);

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・自摸切り
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActTsumoGiri(MJSTkinfo *tk){

	// -----------------------------------------------------------
	// アクション定義(自摸切り)
	// -----------------------------------------------------------

	// アクション牌定義
	if(tk->kyoku[tk->kyoku_index].act_stat[tk->kyoku[tk->kyoku_index].act_count]  == PLYACTRIICH){

		// アクション設定 - 自摸切り処理
		tk->SetActInfo(tk->kyoku_index,
			PLYACTTSUMOGIRI,
			tk->ply_turn,
			4,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count-1]
		);

	}else{

		// アクション設定 - 自摸切り処理
		tk->SetActInfo(tk->kyoku_index,
			PLYACTTSUMOGIRI,
			tk->ply_turn,
			4,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);

	}

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// 卓状態設定（→捨牌処理）
	// -----------------------------------------------------------
	tk->stat = PLYACTSUTE;

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・捨牌
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActSutehai(MJSTkinfo *tk, int sute_hai, bool sute_aka){

	// -----------------------------------------------------------
	// アクション定義(捨牌)
	// -----------------------------------------------------------
	tk->SetActInfo(tk->kyoku_index,
		PLYACTSUTE,
		tk->ply_turn,
		4,
		sute_hai,
		sute_aka
	);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// 卓状態設定（→捨牌処理）
	// -----------------------------------------------------------
	tk->stat = PLYACTSUTE;

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・自摸和了
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActTsumoAgari(MJSTkinfo *tk){

	// -----------------------------------------------------------
	// アクション設定 - 自摸和了
	// -----------------------------------------------------------
	tk->SetActInfo(tk->kyoku_index,
		PLYTSUMOAGARI,
		tk->ply_turn,
		4,
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
		tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
	);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// 和了情報設定
	// -----------------------------------------------------------

	// 和了形式確認
	if( tk->shanten_normal[tk->ply_turn] == -1 ){

		// 通常形式の和了
		tk->SetAgariInfo(tk->kyoku_index,
			AGARI_NORMAL,
			tk->ply_turn,
			4,
			true,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);

	}else if( tk->shanten_chitoi[tk->ply_turn] == -1){

		// 七対子形式の和了
		tk->SetAgariInfo(tk->kyoku_index,
			AGARI_CHITOI,
			tk->ply_turn,
			4,
			true,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);

	}else if( tk->shanten_kokushi[tk->ply_turn] == -1){

		// 国士形式の和了
		tk->SetAgariInfo(tk->kyoku_index,
			AGARI_KOKUSHI,
			tk->ply_turn,
			4,
			true,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);
	}

	// -----------------------------------------------------------
	// 卓状態設定（→自摸和了処理）
	// -----------------------------------------------------------
	tk->stat = PLYTSUMOAGARI;

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・リーチ処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActRiichi(MJSTkinfo *tk){

	// -----------------------------------------------------------
	// アクション設定 - リーチ宣言
	// -----------------------------------------------------------
	tk->SetActInfo(tk->kyoku_index,
		PLYACTRIICH,
		tk->ply_turn,
		4,
		0,
		false
	);

	// -----------------------------------------------------------
	// 卓状態設定（→リーチ処理）
	// -----------------------------------------------------------
	tk->stat = PLYACTRIICH;

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・暗槓処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActAnkan(MJSTkinfo *tk, int kan_hai){

	// -----------------------------------------------------------
	// 状態設定
	// -----------------------------------------------------------
	int tmp_aka_count = 0;       // 赤牌枚数の仮設定

	// -----------------------------------------------------------
	// 赤牌枚数確認
	// -----------------------------------------------------------
	if(kan_hai == 5){
		tmp_aka_count = tk->aka_max[0];
	}else if(kan_hai == 15){
		tmp_aka_count = tk->aka_max[1];
	}else if(kan_hai == 25){
		tmp_aka_count = tk->aka_max[2];
	}else{
		tmp_aka_count = 0;
	}

	// -----------------------------------------------------------
	// アクション設定 - 暗槓
	// -----------------------------------------------------------
	tk->SetActInfo(tk->kyoku_index, 
		PLYACTANKAN, 
		tk->ply_turn, 
		4, 
		kan_hai,
		false
	);

	// -----------------------------------------------------------
	// 晒し情報設定 - 暗槓
	// -----------------------------------------------------------

	tk->SetNakiInfo(tk->kyoku_index, ANKAN, tk->ply_turn, tk->kyoku[tk->kyoku_index].act_count, 
		kan_hai, 
		kan_hai, 
		tmp_aka_count);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// 卓状態設定（→暗槓処理）
	// -----------------------------------------------------------
	tk->stat = PLYACTANKAN;

}

/* ---------------------------------------------------------------------------------------------- */
// 自摸後アクション処理・加槓処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActKakan(MJSTkinfo *tk, int kan_hai, int kan_aka){

	// -----------------------------------------------------------
	// 加槓牌の赤牌枚数確認
	// -----------------------------------------------------------
	if(kan_aka == 0){

		// -----------------------------------------------------------
		// アクション設定 - 加槓(通常牌)
		// -----------------------------------------------------------
		tk->SetActInfo(tk->kyoku_index, 
			PLYACTKAKAN, 
			tk->ply_turn, 
			4, 
			kan_hai,
			false
		);

	}else{

		// -----------------------------------------------------------
		// アクション設定 - 加槓(赤牌)
		// -----------------------------------------------------------
		tk->SetActInfo(tk->kyoku_index, 
			PLYACTKAKAN, 
			tk->ply_turn, 
			4, 
			kan_hai,
			true
		);

	}

	// -----------------------------------------------------------
	// 晒し情報設定 - 加槓
	// -----------------------------------------------------------

	tk->SetNakiInfo(tk->kyoku_index, KAKAN, tk->ply_turn, tk->kyoku[tk->kyoku_index].act_count, 
		kan_hai, 
		kan_hai, 
		kan_aka);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// 卓状態設定（→加槓処理）
	// -----------------------------------------------------------
	tk->stat = PLYACTKAKAN;

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き確認
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::ChkPlayNaki(MJSTkinfo *tk, MJSPlayer *ply){

	// 鳴き確認
	for(int tmp_num = 0; tmp_num < PLAYER_MAX; tmp_num++){

		// -----------------------------------------------------------
		// HUMであれば
		// -----------------------------------------------------------
		if( tk->ply_hum_mode == 1 && tmp_num == HUM_PLY_SEKI_NUM){

			// 処理しない

		// -----------------------------------------------------------
		// COMの鳴きアクションの確認
		// -----------------------------------------------------------
		}else{

			// 手番(捨牌直後)の場合は、鳴きアクションをしない
			if( tmp_num != tk->ply_turn ){

				// 各プレーヤーごとで鳴き確認
				ply[tmp_num].PlyChkNaki(tk->ply_turn, tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count]);

				// 鳴きアクションの設定
				tk->ply_act_naki[tmp_num] = ply[tmp_num].ply_act;

				// 鳴きアクション設定・補足
				if( tk->ply_act_naki[tmp_num] != ACTNONAKI){
					tk->ply_naki_idx[tmp_num]       = ply[tmp_num].ply_naki_idx;
					tk->ply_naki_aka_count[tmp_num] = ply[tmp_num].ply_naki_aka_count;
				}else{
					tk->ply_naki_idx[tmp_num]       = 0;
					tk->ply_naki_aka_count[tmp_num] = 0;
				}

			}else{
				// 鳴きアクションの設定
				tk->ply_act_naki[tmp_num]       = ACTNONAKI;
				tk->ply_naki_idx[tmp_num]       = 0;
				tk->ply_naki_aka_count[tmp_num] = 0;
			}

		}

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetPlayNaki(MJSTkinfo *tk, MJSPlayer *ply){

	// -----------------------------------------------------------
	// 状態設定
	// -----------------------------------------------------------
	int tmp_aka_count = 0;       // 赤牌枚数の仮設定
	tk->stat = PLYACTTSUMOWAIT;  // デバグ用

	// -----------------------------------------------------------
	// ロンのアクション設定
	// -----------------------------------------------------------
	if ( tk->ply_act_naki[0] == ACTRON || tk->ply_act_naki[1] == ACTRON || tk->ply_act_naki[2] == ACTRON || tk->ply_act_naki[3] == ACTRON ){

		// ----------------------------------------
		// ロン処理
		// ----------------------------------------
		TakuActRonAgari(tk);

		// ----------------------------------------
		// プレーヤへの鳴き処理通知
		// ----------------------------------------

	// -----------------------------------------------------------
	// ポンのアクション設定
	// -----------------------------------------------------------
	}else if( tk->ply_act_naki[0] == ACTPON || tk->ply_act_naki[1] == ACTPON || tk->ply_act_naki[2] == ACTPON || tk->ply_act_naki[3] == ACTPON ){

		// ----------------------------------------
		// ポン処理
		// ----------------------------------------
		TakuActPon(tk);

		// ----------------------------------------
		// プレーヤへの鳴き処理通知
		// ----------------------------------------
		for(int tmp_num=0; tmp_num< PLAYER_MAX; tmp_num++){
			if( tk->ply_hum_mode != 1 || tmp_num != HUM_PLY_SEKI_NUM){
				// plyクラスにアクション情報を引き渡し
				 ply[tmp_num].PlyActNaki( tk->naki_ply_num,                                                            // 引数：鳴きプレーヤー番号
				                      ACTPON,                                                                          // 鳴きアクション
				                      tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1],      // 鳴き牌
				                      tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1],      // 鳴きINDEX
				                      tmp_aka_count );                                                                 // 赤牌の枚数
			}
		}

	// -----------------------------------------------------------
	// 明槓のアクション設定
	// -----------------------------------------------------------
	}else if( tk->ply_act_naki[0] == ACTMINKAN || tk->ply_act_naki[1] == ACTMINKAN || tk->ply_act_naki[2] == ACTMINKAN || tk->ply_act_naki[3] == ACTMINKAN ){

		// ----------------------------------------
		// 明槓処理
		// ----------------------------------------
		TakuActMinkan(tk);

		// ----------------------------------------
		// プレーヤへの鳴き処理通知
		// ----------------------------------------
		for(int tmp_num=0; tmp_num< PLAYER_MAX; tmp_num++){
			if( tk->ply_hum_mode != 1 || tmp_num != HUM_PLY_SEKI_NUM){
				// plyクラスにアクション情報を引き渡し
				 ply[tmp_num].PlyActNaki( tk->naki_ply_num,                                                            // 引数：鳴きプレーヤー番号
				                      ACTMINKAN,                                                                       // 鳴きアクション
				                      tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1],      // 鳴き牌
				                      tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1],      // 鳴きINDEX
				                      4 );                                                                             // 赤牌の枚数
			}
		}

	// -----------------------------------------------------------
	// チーのアクション設定
	// -----------------------------------------------------------
	}else if( tk->ply_act_naki[0] == ACTCHI || tk->ply_act_naki[1] == ACTCHI || tk->ply_act_naki[2] == ACTCHI || tk->ply_act_naki[3] == ACTCHI ){

		// ----------------------------------------
		// チー処理
		// ----------------------------------------
		TakuActChi(tk);

		// ----------------------------------------
		// プレーヤへの鳴き処理通知
		// ----------------------------------------
		for(int tmp_num=0; tmp_num< PLAYER_MAX; tmp_num++){
			if( tk->ply_hum_mode != 1 || tmp_num != HUM_PLY_SEKI_NUM){
				// plyクラスにアクション情報を引き渡し
				 ply[tmp_num].PlyActNaki( tk->naki_ply_num,                                                             // 引数：鳴きプレーヤー番号
				                      ACTCHI,                                                                           // 鳴きアクション
				                      tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1],       // 鳴き牌
				                      ply[tk->naki_ply_num].ply_naki_idx,                                               // 鳴きINDEX
				                      tmp_aka_count );                                                                  // 赤牌の枚数
			}
		}

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理・ロン処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActRonAgari(MJSTkinfo *tk){

	// -----------------------------------------------------------
	// 編集初期化
	// -----------------------------------------------------------
	int agari_ply_count = 0;     // 和了プレーヤの数

	// -----------------------------------------------------------
	// 和了プレーヤーの確認
	// -----------------------------------------------------------
	for(int tmp_num=0; tmp_num < PLAYER_MAX; tmp_num++){
		if ( tk->ply_act_naki[tmp_num] == ACTRON){
			// 和了プレーヤーの数
			agari_ply_count++;
			// 和了プレーヤーの設定
			tk->naki_ply_num=tmp_num;
			// 頭ハネのために抜ける
			break;
		}
	}

	// -----------------------------------------------------------
	// アクション設定 - ロン
	// -----------------------------------------------------------
	tk->SetActInfo(tk->kyoku_index,
		PLYACTRON,
		tk->naki_ply_num,
		tk->ply_turn,
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
		tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count] 
	);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// 和了情報設定
	// -----------------------------------------------------------

	// 和了形式確認
	if( tk->shanten_normal[tk->naki_ply_num] == -1 ){

		// 通常形式の和了
		tk->SetAgariInfo(tk->kyoku_index,
			AGARI_NORMAL,
			tk->naki_ply_num,
			tk->ply_turn,
			false,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);

	}else if( tk->shanten_chitoi[tk->naki_ply_num] == -1){

		// 七対形式の和了
		tk->SetAgariInfo(tk->kyoku_index,
			AGARI_CHITOI,
			tk->naki_ply_num,
			tk->ply_turn,
			false,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);

	}else if( tk->shanten_kokushi[tk->naki_ply_num] == -1){

		// 国士形式の和了
		tk->SetAgariInfo(tk->kyoku_index,
			AGARI_KOKUSHI,
			tk->naki_ply_num,
			tk->ply_turn,
			false,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count]
		);

	}

	// -----------------------------------------------------------
	// 卓ステータスの設定
	// -----------------------------------------------------------
	tk->stat = PLYACTRON;

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理・ポン処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPon(MJSTkinfo *tk){

	// ----------------------------------------
	// 関数定義
	// ----------------------------------------
	int tmp_naki_hai  = 0;
	int tmp_aka_count = 0;       // 赤牌枚数の仮設定

	// ----------------------------------------
	// 鳴きプレーヤーの確認
	// ----------------------------------------
	for(int tmp_num=0; tmp_num < PLAYER_MAX; tmp_num++){
		if ( tk->ply_act_naki[tmp_num] == ACTPON){
			// 鳴きプレーヤーの設定
			tk->naki_ply_num=tmp_num;
			break;
		}
	}

	// ----------------------------------------
	// アクション設定 - ポン
	// ----------------------------------------
	tk->SetActInfo(tk->kyoku_index,
			PLYACTPON,
			tk->naki_ply_num,
			tk->ply_turn,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count] 
		);

	// ----------------------------------------
	// 赤牌枚数の設定
	// ----------------------------------------

	// 鳴き牌設定
	tmp_naki_hai = tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count];

	// 通知情報の設定
	tmp_aka_count = tk->ply_naki_aka_count[tk->naki_ply_num];

	// 赤牌の減少
	tk->ply_act_aka_count[tk->naki_ply_num][(tmp_naki_hai-5)/10] = tk->ply_act_aka_count[tk->naki_ply_num][(tmp_naki_hai-5)/10] - tmp_aka_count;

	// 鳴牌が赤牌ならば+1する
	if(tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count] == true){
		tmp_aka_count++;
	}

	// ----------------------------------------
	// 晒し情報設定 - ポン
	// ----------------------------------------
	tk->SetNakiInfo(tk->kyoku_index, MINKO, tk->naki_ply_num, tk->kyoku[tk->kyoku_index].act_count, 
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1], 
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1], 
		tmp_aka_count);

	// ----------------------------------------
	// 自摸順の変更
	// ----------------------------------------
	tk->ply_turn = tk->naki_ply_num;

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// ----------------------------------------
	// 卓ステータスの設定
	// ----------------------------------------
	tk->stat = PLYACTPON;

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理・明槓処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActMinkan(MJSTkinfo *tk){

	// ----------------------------------------
	// 鳴きプレーヤーの確認
	// ----------------------------------------
	for(int tmp_num=0; tmp_num < PLAYER_MAX; tmp_num++){
		if ( tk->ply_act_naki[tmp_num] == ACTMINKAN){
			// 鳴きプレーヤーの設定
			tk->naki_ply_num=tmp_num;
			break;
		}
	}

	// ----------------------------------------
	// アクション設定 - 明槓
	// ----------------------------------------
	tk->SetActInfo(tk->kyoku_index,
			PLYACTMINKAN,
			tk->naki_ply_num,
			tk->ply_turn,
			tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
			tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count] 
		);

	// ----------------------------------------
	// 晒し情報設定 - ポン
	// ----------------------------------------
	tk->SetNakiInfo(tk->kyoku_index, MINKAN, tk->naki_ply_num, tk->kyoku[tk->kyoku_index].act_count, 
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1], 
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1], 
		4);

	// ----------------------------------------
	// 自摸順の変更
	// ----------------------------------------
	tk->ply_turn = tk->naki_ply_num;

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// ----------------------------------------
	// 卓ステータスの設定
	// ----------------------------------------
	tk->stat = PLYACTMINKAN;

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理・チー処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActChi(MJSTkinfo *tk){

	// ----------------------------------------
	// 関数定義
	// ----------------------------------------
	int tmp_aka_count = 0;       // 赤牌枚数の仮設定

	// ----------------------------------------
	// 鳴きプレーヤーの確認
	// ----------------------------------------
	for(int tmp_num=0; tmp_num < PLAYER_MAX; tmp_num++){
		if ( tk->ply_act_naki[tmp_num] == ACTCHI){
			// 鳴きプレーヤーの設定
			tk->naki_ply_num=tmp_num;
			break;
		}
	}

	// ----------------------------------------
	// アクション設定 - チー
	// ----------------------------------------
	tk->SetActInfo(tk->kyoku_index,
		PLYACTCHI,
		tk->naki_ply_num,
		tk->ply_turn,
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count],
		tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count] 
	);

	// ----------------------------------------
	// 赤牌枚数の設定
	// ----------------------------------------
	tmp_aka_count = tk->ply_naki_aka_count[tk->naki_ply_num];

	// 鳴牌が赤牌ならば+1する
	if(tk->kyoku[tk->kyoku_index].act_aka[tk->kyoku[tk->kyoku_index].act_count] == true){
		tmp_aka_count++;
	}

	// ----------------------------------------
	// 晒し情報設定 - チー
	// ----------------------------------------
	tk->SetNakiInfo(tk->kyoku_index, MINSHUN, tk->naki_ply_num, tk->kyoku[tk->kyoku_index].act_count, 
		tk->kyoku[tk->kyoku_index].act_hai[tk->kyoku[tk->kyoku_index].act_count-1], 
		tk->ply_naki_idx[tk->naki_ply_num], 
		tmp_aka_count);

	// ----------------------------------------
	// 自摸順の変更
	// ----------------------------------------
	tk->ply_turn = tk->naki_ply_num;

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// ----------------------------------------
	// 卓ステータスの設定
	// ----------------------------------------
	tk->stat = PLYACTCHI;

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPostNaki(MJSTkinfo *tk, MJSPlayer *ply){

	// HUM・COM処理確認
	if( tk->ply_hum_mode == 1 && tk->ply_turn == HUM_PLY_SEKI_NUM){

		// 自摸後アクション処理・HUMの場合
		TakuActPostNaki_HumPly(tk);

	}else{

		// 自摸後アクションの設定・COMの場合
		TakuActPostNaki_ComPly(tk, ply);

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理(HUM用)
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPostNaki_HumPly(MJSTkinfo *tk){

	tk->SetActInfo(tk->kyoku_index,
		PLYACTNAKISUTE,
		tk->ply_turn,
		4,
		tk->ply_act_tehaitbl[HUM_PLY_SEKI_NUM][tk->ply_tbl_hum_sutehai_statnum],      // ※※捨牌関数に変更
		tk->ply_act_tehai_tbl_aka[HUM_PLY_SEKI_NUM][tk->ply_tbl_hum_sutehai_statnum]  // ※※捨牌関数に変更
	);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

}

/* ---------------------------------------------------------------------------------------------- */
// 鳴き後アクション処理(COM用)
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuActPostNaki_ComPly(MJSTkinfo *tk, MJSPlayer *ply){

	// プレーヤーの捨牌処理
	ply[tk->ply_turn].PlyActNakiSute();

	// 自摸後アクションの設定
	tk->ply_act = ply[tk->ply_turn].ply_act;

	// プレーヤーアクションの確認
	if( tk->ply_act == ACTSUTE || tk->ply_act == ACTNAKISUTE ){

		tk->SetActInfo(tk->kyoku_index,
			PLYACTNAKISUTE,
			tk->ply_turn,
			4,
			ply[tk->ply_turn].ply_sute_hai,
			ply[tk->ply_turn].ply_sute_aka
		);

	}else{

		// (デバグ用)一番右の牌を強制捨牌

	}

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

}

/* ---------------------------------------------------------------------------------------------- */
// 荒牌処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetHowanpai(MJSTkinfo *tk, MJSPlayer *ply){

	// -----------------------------------------------------------
	// 局終了設定(荒牌)
	// -----------------------------------------------------------
	tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ryukyoku_flg  = true;
	tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ryukyoku_stat = HOWANPAI;
	tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].yakuman_count = 0;
	tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].yakucount     = 0;

	// -----------------------------------------------------------
	// アクション設定 - 荒局
	// -----------------------------------------------------------
	tk->SetActInfo(tk->kyoku_index,
		RYUKYOKU,
		4,
		4,
		0,
		false
	);

	// -----------------------------------------------------------
	// tkクラスのアクション情報の最新化
	// -----------------------------------------------------------
	tk->Check_Ply_ActTehai(tk->kyoku_index, tk->kyoku[tk->kyoku_index].act_count);

	// -----------------------------------------------------------
	// テンパイ人数確認
	// -----------------------------------------------------------

	tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count = 0;
	for(int tmp_num = 0; tmp_num < PLAYER_MAX; tmp_num++){
		// テンパイ確認
		if( tk->shanten_total[tmp_num] == 0 ){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] = true;
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count++;
		}else{
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] = false;
		}

	}

	// -----------------------------------------------------------
	// 得点設定
	// -----------------------------------------------------------
	for(int tmp_num = 0; tmp_num< PLAYER_MAX; tmp_num++){
		if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 0 || tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 4){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = 0;
		}else if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 1 && tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] == true){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = 3000;
		}else if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 1 && tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] == false){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = -1000;
		}else if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 2 && tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] == true){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = 1500;
		}else if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 2 && tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] == false){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = -1500;
		}else if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 3 && tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] == true){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = 1000;
		}else if(tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_count == 3 && tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ply_tempai_flg[tmp_num] == false){
			tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_num] = -3000;
		}
	}

	// 局終了得点の設定
	for(int tmp_i = 0; tmp_i < PLAYER_MAX; tmp_i++){
		tk->kyoku[tk->kyoku_index].ply_kyoku_end_score[tmp_i] = tk->kyoku[tk->kyoku_index].ply_kyoku_start_score[tmp_i] 
		                                                      + tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].kyoku_score[tmp_i];
	}

	// -----------------------------------------------------------
	// プレーヤークラスに通知
	// -----------------------------------------------------------
	for(int tmp_num = 0; tmp_num< PLAYER_MAX; tmp_num++){
		if( tk->ply_hum_mode != 1 || tmp_num != HUM_PLY_SEKI_NUM){
			// plyクラスにアクション情報を引き渡し
			// ply[tmp_num].PlySetHowanpai(tk->naki_ply_num);    // 引数：鳴きプレーヤー番号
		}
	}

}

/* ---------------------------------------------------------------------------------------------- */
// 次局初期化処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::KyokuNextInit(MJSTkinfo *tk, MJSPlayer *ply){

	// -----------------------------------------------------------
	// モードごとでの次局の切り替え
	// -----------------------------------------------------------

	// -----------------------------------------------------------
	// 検証モード
	// -----------------------------------------------------------
	if( tk->tkgame_type == TKGAME_MAXID_TEST ){
		// 次局に移るか？
		if ( tk->kyoku_index < KYOKU_MAX - 1 ){
			// 局INDEXの加算
			tk->kyoku_index++;
			// プレーヤー家の移動
			tk->kyoku[tk->kyoku_index].ie[0] = 1;   // プレーヤー01は西家
			tk->kyoku[tk->kyoku_index].ie[1] = 2;   // プレーヤー02は北家
			tk->kyoku[tk->kyoku_index].ie[2] = 3;   // プレーヤー03は東家
			tk->kyoku[tk->kyoku_index].ie[3] = 0;   // プレーヤー04は南家
			tk->kyoku[tk->kyoku_index].kyoku_oya = 3;
			// ツミ棒・リーチ棒
			tk->kyoku[tk->kyoku_index].kyoku   = tk->kyoku[tk->kyoku_index-1].kyoku;
			tk->kyoku[tk->kyoku_index].tsumibo = tk->kyoku[tk->kyoku_index-1].tsumibo;
			tk->kyoku[tk->kyoku_index].riichbo = tk->kyoku[tk->kyoku_index-1].riichbo;
			// 得点移動
			for(int tmp_num = 0; tmp_num< PLAYER_MAX; tmp_num++){
				tk->kyoku[tk->kyoku_index].ply_kyoku_start_score[tmp_num] = tk->kyoku[tk->kyoku_index-1].ply_kyoku_end_score[tmp_num];
			}
			// 状態設定
			tk->stat = KYOKUSTART;
		}else{
			// 状態設定
			tk->stat = TAKURESULT;
		}

	// -----------------------------------------------------------
	// 東風モード
	// -----------------------------------------------------------
	}else if( tk->tkgame_type == TKGAME_TONPU ){

		// 次局に移るか？
		if ( tk->kyoku[tk->kyoku_index].kyoku < 3 ){

			// 親和了
			if( tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].ryukyoku_flg  == false &&
			    tk->kyoku[tk->kyoku_index].ply_agari_yk[tk->kyoku[tk->kyoku_index].agari_ply_count].agari_ply_num == tk->kyoku[tk->kyoku_index].kyoku_oya){

				// 局INDEXの加算
				tk->kyoku_index++;
				// プレーヤー家の固定
				tk->kyoku[tk->kyoku_index].ie[0]     = tk->kyoku[tk->kyoku_index-1].ie[0];       // プレーヤー01
				tk->kyoku[tk->kyoku_index].ie[1]     = tk->kyoku[tk->kyoku_index-1].ie[1];       // プレーヤー02
				tk->kyoku[tk->kyoku_index].ie[2]     = tk->kyoku[tk->kyoku_index-1].ie[2];       // プレーヤー03
				tk->kyoku[tk->kyoku_index].ie[3]     = tk->kyoku[tk->kyoku_index-1].ie[3];       // プレーヤー04
				tk->kyoku[tk->kyoku_index].kyoku_oya = tk->kyoku[tk->kyoku_index-1].kyoku_oya;   // 親番
				// 局番号・ツミ棒・リーチ棒
				tk->kyoku[tk->kyoku_index].kyoku   = tk->kyoku[tk->kyoku_index-1].kyoku;    
				tk->kyoku[tk->kyoku_index].tsumibo = tk->kyoku[tk->kyoku_index-1].tsumibo + 1; // ツミ棒加算
				tk->kyoku[tk->kyoku_index].riichbo = tk->kyoku[tk->kyoku_index-1].riichbo;
				// 得点移動
				for(int tmp_num = 0; tmp_num< PLAYER_MAX; tmp_num++){
					tk->kyoku[tk->kyoku_index].ply_kyoku_start_score[tmp_num] = tk->kyoku[tk->kyoku_index-1].ply_kyoku_end_score[tmp_num];
				}
				// 状態設定
				tk->stat = KYOKUSTART;

			// 子和了
			}else{

				// 局INDEXの加算
				tk->kyoku_index++;
				// プレーヤー家の移動
				tk->kyoku[tk->kyoku_index].ie[0]     = (tk->kyoku[tk->kyoku_index-1].ie[0] + 3) % 4;       // プレーヤー01
				tk->kyoku[tk->kyoku_index].ie[1]     = (tk->kyoku[tk->kyoku_index-1].ie[1] + 3) % 4;       // プレーヤー02
				tk->kyoku[tk->kyoku_index].ie[2]     = (tk->kyoku[tk->kyoku_index-1].ie[2] + 3) % 4;       // プレーヤー03
				tk->kyoku[tk->kyoku_index].ie[3]     = (tk->kyoku[tk->kyoku_index-1].ie[3] + 3) % 4;       // プレーヤー04
				tk->kyoku[tk->kyoku_index].kyoku_oya = (tk->kyoku[tk->kyoku_index-1].kyoku_oya + 1) % 4;   // 親番
				// 局番号・ツミ棒・リーチ棒
				tk->kyoku[tk->kyoku_index].kyoku   = tk->kyoku[tk->kyoku_index-1].kyoku + 1;    // 局番号加算
				tk->kyoku[tk->kyoku_index].tsumibo = 0;                                        // ツミ棒クリア
				tk->kyoku[tk->kyoku_index].riichbo = tk->kyoku[tk->kyoku_index-1].riichbo;
				// 得点移動
				for(int tmp_num = 0; tmp_num< PLAYER_MAX; tmp_num++){
					tk->kyoku[tk->kyoku_index].ply_kyoku_start_score[tmp_num] = tk->kyoku[tk->kyoku_index-1].ply_kyoku_end_score[tmp_num];
				}
				// 状態設定
				tk->stat = KYOKUSTART;
			}

		// 局終了
		}else{
			// 状態設定
			tk->stat = TAKURESULT;
		}

	// -----------------------------------------------------------
	// 一局モード
	// -----------------------------------------------------------
	}else if( tk->tkgame_type == TKGAME_1KYOKU ){

		// 状態設定
		tk->stat = TAKURESULT;

	// -----------------------------------------------------------
	// その他(デバグ用)
	// -----------------------------------------------------------
	}else{

		// 状態設定
		tk->stat = TAKURESULT;

	}

}

/* ---------------------------------------------------------------------------------------------- */
// 卓終了情報設定
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::SetTakuReSult(MJSTkinfo *tk, MJSPlayer *ply){

	// 変数定義
	int tmp_rank_score[4];
	int tmp_ply_score[4];
	int tmpchk[4];
	int tmpNum;

	// 得点集計
	for(int tmp_num = 0; tmp_num< PLAYER_MAX; tmp_num++){

		// 仮順位得点 tmp_rank_score[順位] = 獲得得点
		tmp_rank_score[tmp_num]  = ( tk->kyoku[tk->kyoku_index].ply_kyoku_end_score[tmp_num] - tk->init_score) / 1000;

		// 仮ply得点  tmp_ply_score[プレーヤー番号] = 獲得得点
		tmp_ply_score[tmp_num]   = ( tk->kyoku[tk->kyoku_index].ply_kyoku_end_score[tmp_num] - tk->init_score) / 1000;

		// 作業用チェックフラグ設定
		tmpchk[tmp_num] = 0;
	}

	// 順位並び替え
	for (int tmp_a = 0; tmp_a < 3; tmp_a++){
		for (int tmp_b = tmp_a+1; tmp_b < PLAYER_MAX; tmp_b++){
			// 作業用スコアの入れ替え
			if ( tmp_rank_score[tmp_b] > tmp_rank_score[tmp_a] ){
				 tmpNum                = tmp_rank_score[tmp_a];
				 tmp_rank_score[tmp_a] = tmp_rank_score[tmp_b];
				 tmp_rank_score[tmp_b] = tmpNum;
			}
		}
	}

	// プレーヤーと関連付け
	for (int rank = 0; rank < PLAYER_MAX; rank++){
		for (int tmp_ply_num = 0; tmp_ply_num < PLAYER_MAX; tmp_ply_num++){
			if( tmp_rank_score[rank] == tmp_ply_score[tmp_ply_num] && tmpchk[tmp_ply_num]!=999 ){
				tk->plyjun[rank] = tmp_ply_num;                // plyjun[順位] = プレーヤー番号
				tk->plyEndscore[rank] = tmp_rank_score[rank];
				tmpchk[tmp_ply_num] = 999;
				break;
			}
		}
	}


}

/* ---------------------------------------------------------------------------------------------- */
// 卓終了処理
/* ---------------------------------------------------------------------------------------------- */
void MJSTaku::TakuGameEnd(MJSTkinfo *tk, MJSPlayer *ply){


}

/* ---------------------------------------------------------------------------------------------- */
// ソース終了
/* ---------------------------------------------------------------------------------------------- */
